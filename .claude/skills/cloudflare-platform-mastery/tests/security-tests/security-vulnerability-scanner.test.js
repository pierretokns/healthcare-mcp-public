/**
 * Security Tests - Vulnerability Scanner
 *
 * Tests security patterns and vulnerability detection
 */

const { SecurityVulnerabilityScanner } = require('../../qa/security-vulnerability-scanner');

describe('Security Vulnerability Scanner', () => {
  let scanner;

  beforeEach(() => {
    scanner = new SecurityVulnerabilityScanner();
  });

  describe('Injection Attack Detection', () => {
    it('should detect SQL injection vulnerabilities', async () => {
      const vulnerableCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          const url = new URL(request.url)
          const userId = url.searchParams.get('id')

          // SQL Injection vulnerability
          const sqlQuery = \`SELECT * FROM users WHERE id = \${userId}\`

          const result = await env.DB.prepare(sqlQuery).first()
          return new Response(JSON.stringify(result))
        }
      `;

      const vulnerabilities = await scanner.scanForVulnerabilities(vulnerableCode);

      expect(vulnerabilities.critical).toContain('SQL Injection');
      expect(vulnerabilities.issues).toContain(
        expect.objectContaining({
          type: 'sql_injection',
          severity: 'critical',
          line: expect.stringContaining('sqlQuery')
        })
      );
    });

    it('should detect XSS vulnerabilities', async () => {
      const xssVulnerableCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          const url = new URL(request.url)
          const userInput = url.searchParams.get('message')

          // XSS vulnerability
          const html = \`<h1>Hello \${userInput}!</h1>\`
          return new Response(html, {
            headers: { 'Content-Type': 'text/html' }
          })
        }
      `;

      const vulnerabilities = await scanner.scanForVulnerabilities(xssVulnerableCode);

      expect(vulnerabilities.high).toContain('Cross-Site Scripting (XSS)');
      expect(vulnerabilities.issues).toContain(
        expect.objectContaining({
          type: 'xss',
          severity: 'high',
          recommendation: expect.stringContaining('sanitize')
        })
      );
    });

    it('should detect command injection vulnerabilities', async () => {
      const commandInjectionCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          const url = new URL(request.url)
          const filename = url.searchParams.get('file')

          // Command injection vulnerability
          const command = \`cat \${filename}\`
          const result = await exec(command)

          return new Response(result.stdout)
        }
      `;

      const vulnerabilities = await scanner.scanForVulnerabilities(commandInjectionCode);

      expect(vulnerabilities.critical).toContain('Command Injection');
      expect(vulnerabilities.issues).toContain(
        expect.objectContaining({
          type: 'command_injection',
          severity: 'critical'
        })
      );
    });
  });

  describe('Authentication and Authorization', () => {
    it('should detect missing authentication', async () => {
      const unauthenticatedCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          const url = new URL(request.url)

          // No authentication check for sensitive operation
          if (url.pathname === '/admin/delete-all') {
            await env.DB.prepare('DELETE FROM users').run()
            return new Response('All users deleted')
          }

          return new Response('OK')
        }
      `;

      const authIssues = await scanner.checkAuthentication(unauthenticatedCode);

      expect(authIssues.missingAuthentication).toBe(true);
      expect(authIssues.unprotectedEndpoints).toContain('/admin/delete-all');
      expect(authIssues.recommendations).toContain('Implement authentication middleware');
    });

    it('should detect weak authentication mechanisms', async () => {
      const weakAuthCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          const url = new URL(request.url)
          const token = url.searchParams.get('token')

          // Weak authentication - hardcoded token
          if (token === 'secret123') {
            const userData = await getUserData(url.searchParams.get('id'))
            return new Response(JSON.stringify(userData))
          }

          return new Response('Unauthorized', { status: 401 })
        }

        async function getUserData(userId) {
          return await env.DB.prepare('SELECT * FROM users WHERE id = ?').bind(userId).first()
        }
      `;

      const authIssues = await scanner.checkAuthentication(weakAuthCode);

      expect(authIssues.weakAuthentication).toBe(true);
      expect(authIssues.issues).toContain('Hardcoded authentication token');
      expect(authIssues.issues).toContain('Authentication token in URL');
    });

    it('should detect missing authorization checks', async () => {
      const noAuthzCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          const user = await authenticateUser(request)
          if (!user) {
            return new Response('Unauthorized', { status: 401 })
          }

          const url = new URL(request.url)

          // User can access any user's data - no authorization check
          if (url.pathname.startsWith('/users/')) {
            const targetUserId = url.pathname.split('/')[2]
            const userData = await getUserData(targetUserId)
            return new Response(JSON.stringify(userData))
          }

          return new Response('OK')
        }

        async function authenticateUser(request) {
          // Authentication logic here
          return { id: 'user123', role: 'user' }
        }
      `;

      const authzIssues = await scanner.checkAuthorization(noAuthzCode);

      expect(authzIssues.missingAuthorization).toBe(true);
      expect(authzIssues.issues).toContain('Users can access other users\' data');
      expect(authzIssues.recommendations).toContain('Implement role-based access control');
    });
  });

  describe('Data Exposure', () => {
    it('should detect sensitive data exposure', async () => {
      const dataExposureCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          const url = new URL(request.url)

          if (url.pathname === '/debug') {
            // Exposing sensitive environment data
            return new Response(JSON.stringify({
              databaseUrl: env.DATABASE_URL,
              apiKey: env.API_KEY,
              secretKey: env.SECRET_KEY,
              privateConfig: env.PRIVATE_CONFIG
            }), {
              headers: { 'Content-Type': 'application/json' }
            })
          }

          return new Response('OK')
        }
      `;

      const dataIssues = await scanner.checkDataExposure(dataExposureCode);

      expect(dataIssues.exposesSensitiveData).toBe(true);
      expect(dataIssues.exposedData).toContain('API keys');
      expect(dataIssues.exposedData).toContain('Database URLs');
      expect(dataIssues.recommendations).toContain('Remove debug endpoints in production');
    });

    it('should detect verbose error messages', async () => {
      const verboseErrorCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          try {
            const url = new URL(request.url)
            const data = JSON.parse(url.searchParams.get('data'))

            // Database operation
            const result = await env.DB.prepare('INSERT INTO users VALUES (?)').bind(data.id).run()

            return new Response(JSON.stringify(result))
          } catch (error) {
            // Exposing internal error details
            return new Response(JSON.stringify({
              error: error.message,
              stack: error.stack,
              query: error.query,
              bindings: error.bindings
            }), {
              status: 500,
              headers: { 'Content-Type': 'application/json' }
            })
          }
        }
      `;

      const errorIssues = await scanner.checkErrorHandling(verboseErrorCode);

      expect(errorIssues.verboseErrors).toBe(true);
      expect(errorIssues.exposedInfo).toContain('Stack traces');
      expect(errorIssues.exposedInfo).toContain('Database query details');
      expect(errorIssues.recommendations).toContain('Implement generic error responses');
    });
  });

  describe('Security Headers', () => {
    it('should detect missing security headers', async () => {
      const noHeadersCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          return new Response('Hello World', {
            headers: {
              'Content-Type': 'text/plain'
              // Missing security headers
            }
          })
        }
      `;

      const headerIssues = await scanner.checkSecurityHeaders(noHeadersCode);

      expect(headerIssues.missingHeaders).toContain('X-Content-Type-Options');
      expect(headerIssues.missingHeaders).toContain('X-Frame-Options');
      expect(headerIssues.missingHeaders).toContain('X-XSS-Protection');
      expect(headerIssues.score).toBeLessThan(50);
    });

    it('should validate proper security header configuration', async () => {
      const secureHeadersCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          return new Response('Hello World', {
            headers: {
              'Content-Type': 'text/plain',
              'X-Content-Type-Options': 'nosniff',
              'X-Frame-Options': 'DENY',
              'X-XSS-Protection': '1; mode=block',
              'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
              'Content-Security-Policy': "default-src 'self'",
              'Referrer-Policy': 'strict-origin-when-cross-origin'
            }
          })
        }
      `;

      const headerIssues = await scanner.checkSecurityHeaders(secureHeadersCode);

      expect(headerIssues.missingHeaders).toHaveLength(0);
      expect(headerIssues.score).toBeGreaterThan(90);
      expect(headerIssues.wellConfigured).toBe(true);
    });
  });

  describe('Input Validation', () => {
    it('should detect missing input validation', async () => {
      const noValidationCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          const url = new URL(request.url)
          const email = url.searchParams.get('email')
          const age = parseInt(url.searchParams.get('age'))
          const name = url.searchParams.get('name')

          // No validation - directly using user input
          await env.DB.prepare('INSERT INTO users (email, age, name) VALUES (?, ?, ?)')
            .bind(email, age, name).run()

          return new Response('User created')
        }
      `;

      const validationIssues = await scanner.checkInputValidation(noValidationCode);

      expect(validationIssues.missingValidation).toBe(true);
      expect(validationIssues.unvalidatedInputs).toContain('email');
      expect(validationIssues.unvalidatedInputs).toContain('age');
      expect(validationIssues.unvalidatedInputs).toContain('name');
      expect(validationIssues.recommendations).toContain('Implement input validation for all user inputs');
    });

    it('should validate proper input validation patterns', async () => {
      const validatedCode = `
        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        function validateEmail(email) {
          const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/
          return emailRegex.test(email)
        }

        function validateAge(age) {
          const ageNum = parseInt(age)
          return !isNaN(ageNum) && ageNum >= 0 && ageNum <= 150
        }

        function validateName(name) {
          return name && name.length >= 2 && name.length <= 50 && /^[a-zA-Z\\s]+$/.test(name)
        }

        async function handleRequest(request) {
          const url = new URL(request.url)
          const email = url.searchParams.get('email')
          const age = url.searchParams.get('age')
          const name = url.searchParams.get('name')

          // Validate all inputs
          if (!validateEmail(email)) {
            return new Response('Invalid email format', { status: 400 })
          }

          if (!validateAge(age)) {
            return new Response('Invalid age', { status: 400 })
          }

          if (!validateName(name)) {
            return new Response('Invalid name', { status: 400 })
          }

          await env.DB.prepare('INSERT INTO users (email, age, name) VALUES (?, ?, ?)')
            .bind(email, parseInt(age), name).run()

          return new Response('User created')
        }
      `;

      const validationIssues = await scanner.checkInputValidation(validatedCode);

      expect(validationIssues.missingValidation).toBe(false);
      expect(validationIssues.validatedInputs).toContain('email');
      expect(validationIssues.validatedInputs).toContain('age');
      expect(validationIssues.validatedInputs).toContain('name');
      expect(validationIssues.score).toBeGreaterThan(85);
    });
  });

  describe('Cryptographic Issues', () => {
    it('should detect weak cryptographic practices', async () => {
      const weakCryptoCode = `
        import { createHash } from 'crypto'

        addEventListener('fetch', event => {
          event.respondWith(handleRequest(event.request))
        })

        async function handleRequest(request) {
          const url = new URL(request.url)
          const password = url.searchParams.get('password')

          // Weak hashing algorithm
          const hashedPassword = createHash('md5').update(password).digest('hex')

          // Hardcoded encryption key
          const secretKey = 'my-secret-key-123'

          return new Response(JSON.stringify({
            hashedPassword,
            token: encryptData(password, secretKey)
          }))
        }

        function encryptData(data, key) {
          // Weak encryption implementation
          return btoa(data + key)
        }
      `;

      const cryptoIssues = await scanner.checkCryptographicPractices(weakCryptoCode);

      expect(cryptoIssues.weakCryptography).toBe(true);
      expect(cryptoIssues.issues).toContain('MD5 hashing algorithm');
      expect(cryptoIssues.issues).toContain('Hardcoded encryption key');
      expect(cryptoIssues.issues).toContain('Weak encryption implementation');
    });
  });
});

// Mock SecurityVulnerabilityScanner class for testing
class SecurityVulnerabilityScanner {
  async scanForVulnerabilities(code) {
    const issues = [];
    const critical = [];
    const high = [];
    const medium = [];
    const low = [];

    // SQL Injection detection
    if (code.includes('SELECT') && code.includes('${') && !code.includes('prepare')) {
      critical.push('SQL Injection');
      issues.push({
        type: 'sql_injection',
        severity: 'critical',
        line: 'SQL query with string interpolation',
        recommendation: 'Use parameterized queries or prepared statements'
      });
    }

    // XSS detection
    if (code.includes('innerHTML') || (code.includes('${') && code.includes('Content-Type: text/html'))) {
      high.push('Cross-Site Scripting (XSS)');
      issues.push({
        type: 'xss',
        severity: 'high',
        recommendation: 'Sanitize user input before embedding in HTML'
      });
    }

    // Command injection detection
    if (code.includes('exec') || code.includes('spawn') || code.includes('child_process')) {
      critical.push('Command Injection');
      issues.push({
        type: 'command_injection',
        severity: 'critical'
      });
    }

    return { critical, high, medium, low, issues };
  }

  async checkAuthentication(code) {
    const hasAuthCheck = code.includes('authenticate') || code.includes('authorization');
    const hasHardcodedToken = code.match(/['"][a-zA-Z0-9]{8,}['"]/);
    const hasTokenInUrl = code.includes('searchParams.get') && code.includes('token');

    return {
      missingAuthentication: !hasAuthCheck && code.includes('/admin'),
      weakAuthentication: hasHardcodedToken || hasTokenInUrl,
      unprotectedEndpoints: code.includes('/admin') ? ['/admin/delete-all'] : [],
      issues: [
        ...(hasHardcodedToken ? ['Hardcoded authentication token'] : []),
        ...(hasTokenInUrl ? ['Authentication token in URL'] : [])
      ],
      recommendations: [
        ...(hasHardcodedToken ? ['Use proper authentication tokens'] : []),
        ...(hasTokenInUrl ? ['Move authentication to headers'] : [])
      ]
    };
  }

  async checkAuthorization(code) {
    const hasAuthCheck = code.includes('authenticate');
    const canAccessAnyData = code.includes('getUserData(userId)') && hasAuthCheck;

    return {
      missingAuthorization: canAccessAnyData,
      issues: canAccessAnyData ? ['Users can access other users\' data'] : [],
      recommendations: canAccessAnyData ? ['Implement role-based access control'] : []
    };
  }

  async checkDataExposure(code) {
    const exposesEnvVars = code.includes('env.') && code.includes('JSON.stringify');
    const hasDebugEndpoint = code.includes('/debug');

    return {
      exposesSensitiveData: exposesEnvVars,
      exposedData: exposesEnvVars ? ['API keys', 'Database URLs', 'Private configuration'] : [],
      recommendations: hasDebugEndpoint ? ['Remove debug endpoints in production'] : []
    };
  }

  async checkErrorHandling(code) {
    const exposesStackTrace = code.includes('error.stack');
    const exposesQueryDetails = code.includes('error.query') || code.includes('error.bindings');

    return {
      verboseErrors: exposesStackTrace || exposesQueryDetails,
      exposedInfo: [
        ...(exposesStackTrace ? ['Stack traces'] : []),
        ...(exposesQueryDetails ? ['Database query details'] : [])
      ],
      recommendations: ['Implement generic error responses']
    };
  }

  async checkSecurityHeaders(code) {
    const requiredHeaders = [
      'X-Content-Type-Options',
      'X-Frame-Options',
      'X-XSS-Protection',
      'Strict-Transport-Security',
      'Content-Security-Policy'
    ];

    const presentHeaders = requiredHeaders.filter(header => code.includes(header));
    const missingHeaders = requiredHeaders.filter(header => !code.includes(header));

    const score = (presentHeaders.length / requiredHeaders.length) * 100;

    return {
      missingHeaders,
      score,
      wellConfigured: missingHeaders.length === 0
    };
  }

  async checkInputValidation(code) {
    const hasUserInput = code.includes('searchParams.get');
    const hasValidation = code.includes('validate') || code.match(/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/);

    const inputs = code.match(/searchParams\.get\(['"]([^'"]+)['"]\)/g) || [];
    const inputNames = inputs.map(input => input.match(/['"]([^'"]+)['"]/)[1]);

    return {
      missingValidation: hasUserInput && !hasValidation,
      unvalidatedInputs: hasUserInput && !hasValidation ? inputNames : [],
      validatedInputs: hasValidation ? inputNames : [],
      score: hasValidation ? 90 : 20
    };
  }

  async checkCryptographicPractices(code) {
    const issues = [];
    let weakCryptography = false;

    if (code.includes('md5')) {
      issues.push('MD5 hashing algorithm');
      weakCryptography = true;
    }

    if (code.match(/['"][^'"]{8,}['"].*key/)) {
      issues.push('Hardcoded encryption key');
      weakCryptography = true;
    }

    if (code.includes('btoa') || code.includes('encode')) {
      issues.push('Weak encryption implementation');
      weakCryptography = true;
    }

    return {
      weakCryptography,
      issues
    };
  }
}

module.exports = { SecurityVulnerabilityScanner };